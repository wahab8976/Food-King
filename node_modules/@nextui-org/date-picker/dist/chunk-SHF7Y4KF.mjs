"use client";
import {
  useDatePickerBase
} from "./chunk-MSEJT5RL.mjs";

// src/use-date-picker.ts
import { useMemo } from "react";
import { datePicker } from "@nextui-org/theme";
import { useDatePickerState } from "@react-stately/datepicker";
import { useDatePicker as useAriaDatePicker } from "@react-aria/datepicker";
import { clsx, dataAttr, objectToDeps } from "@nextui-org/shared-utils";
import { mergeProps } from "@react-aria/utils";
function useDatePicker({
  className,
  classNames,
  ...originalProps
}) {
  const {
    domRef,
    endContent,
    selectorIcon,
    createCalendar,
    isCalendarHeaderExpanded,
    disableAnimation,
    CalendarTopContent,
    slotsProps,
    timeMinValue,
    timeMaxValue,
    CalendarBottomContent,
    dateInputProps,
    timeInputProps,
    popoverProps,
    calendarProps,
    variantProps,
    userTimeInputProps,
    selectorButtonProps,
    selectorIconProps
  } = useDatePickerBase(originalProps);
  let state = useDatePickerState({
    ...originalProps,
    shouldCloseOnSelect: () => !state.hasTime
  });
  const baseStyles = clsx(classNames == null ? void 0 : classNames.base, className);
  const slots = useMemo(
    () => datePicker({
      ...variantProps,
      className
    }),
    [objectToDeps(variantProps), className]
  );
  let {
    groupProps,
    labelProps,
    fieldProps,
    buttonProps,
    dialogProps,
    calendarProps: ariaCalendarProps,
    descriptionProps,
    errorMessageProps
  } = useAriaDatePicker(originalProps, state, domRef);
  originalProps.maxValue && "hour" in originalProps.maxValue ? originalProps.maxValue : null;
  const timeGranularity = state.granularity === "hour" || state.granularity === "minute" || state.granularity === "second" ? state.granularity : null;
  const showTimeField = !!timeGranularity;
  const getDateInputProps = () => {
    return {
      ...dateInputProps,
      groupProps,
      labelProps,
      createCalendar,
      errorMessageProps,
      descriptionProps,
      ...mergeProps(variantProps, fieldProps, {
        minValue: originalProps.minValue,
        maxValue: originalProps.maxValue,
        fullWidth: true,
        disableAnimation
      }),
      className: slots.base({ class: baseStyles }),
      "data-open": dataAttr(state.isOpen)
    };
  };
  const getTimeInputProps = () => {
    var _a, _b;
    if (!showTimeField)
      return {};
    return {
      ...timeInputProps,
      value: state.timeValue,
      onChange: state.setTimeValue,
      granularity: timeGranularity,
      minValue: timeMinValue != null ? timeMinValue : void 0,
      maxValue: timeMaxValue != null ? timeMaxValue : void 0,
      classNames: {
        base: slots.timeInput({
          class: clsx(classNames == null ? void 0 : classNames.timeInput, (_a = userTimeInputProps == null ? void 0 : userTimeInputProps.classNames) == null ? void 0 : _a.base)
        }),
        label: slots.timeInputLabel({
          class: clsx(classNames == null ? void 0 : classNames.timeInputLabel, (_b = userTimeInputProps == null ? void 0 : userTimeInputProps.classNames) == null ? void 0 : _b.label)
        })
      }
    };
  };
  const getPopoverProps = (props = {}) => {
    var _a, _b;
    return {
      state,
      dialogProps,
      ...popoverProps,
      classNames: {
        content: slots.popoverContent({
          class: clsx(
            classNames == null ? void 0 : classNames.popoverContent,
            (_b = (_a = slotsProps.popoverProps) == null ? void 0 : _a.classNames) == null ? void 0 : _b["content"],
            props.className
          )
        })
      }
    };
  };
  const getCalendarProps = () => {
    return {
      ...ariaCalendarProps,
      ...calendarProps,
      classNames: {
        base: slots.calendar({ class: classNames == null ? void 0 : classNames.calendar }),
        content: slots.calendarContent({ class: classNames == null ? void 0 : classNames.calendarContent })
      }
    };
  };
  const getSelectorButtonProps = () => {
    return {
      ...buttonProps,
      ...selectorButtonProps,
      className: slots.selectorButton({ class: classNames == null ? void 0 : classNames.selectorButton })
    };
  };
  const getSelectorIconProps = () => {
    return {
      ...selectorIconProps,
      className: slots.selectorIcon({ class: classNames == null ? void 0 : classNames.selectorIcon })
    };
  };
  return {
    state,
    endContent,
    selectorIcon,
    showTimeField,
    isCalendarHeaderExpanded,
    disableAnimation,
    CalendarTopContent,
    CalendarBottomContent,
    getDateInputProps,
    getPopoverProps,
    getSelectorButtonProps,
    getCalendarProps,
    getTimeInputProps,
    getSelectorIconProps
  };
}

export {
  useDatePicker
};
